# ${license-info}
# ${developer-info}
# ${author-info}


package NCM::Component::oramonserver;

#
# a few standard statements, mandatory for all components
#

use strict;
use NCM::Component;
use vars qw(@ISA $EC);
@ISA = qw(NCM::Component);
$EC=LC::Exception::Context->new->will_store_all;

use NCM::Check;
use LC::Process qw(run);

use LC::File qw(copy file_contents move differ);

#use Data::Dumper;
my $configFile = "/etc//oramon-server.conf";

##########################################################################
sub Configure {
##########################################################################
    my ($self,$config)=@_;
    
    my %classes;
    my %metrics;
    
    my $filecontents = "";
    
    my $root='/software/components/oramonserver/conf/';
    
    #hardcoded for now
    my $header = "#\n".
	"# Generated by ncm-oramonserver at ".scalar(localtime)."\n".
	"#\n".
	"MR\n".
	"\tAttributes\n".
	"\t\tversion 0.0.2\n".
	"\tCommonFields\n".
	"\t\tnodename\n".
	"\t\t\tType CHAR\n".
	"\t\t\tPrimaryKey\n".
	"\t\t\tFieldLength 256\n".
	"\t\ttimestamp\n".
	"\t\t\tType INTEGER\n".
	"\t\t\tPrimaryKey\n";
    
    $filecontents .= $header;
    
    #Part 1: Adventure in the Metric Classes Thicket
    #extracts info of metric classes
    
    my $classPathBase = $root.'sensor/';
    
    unless ($config->elementExists($classPathBase)) {
	$self->error("cannot get $classPathBase");
	return;
    }
    
    my $sensor = $config->getElement($classPathBase);
    
    my $class_key = 0; #artificial key for classes
    
    while ($sensor->hasNextElement() ) {
	my $tmp_el = $sensor->getNextElement();
	my $classPath = $tmp_el->getPath()->toString()."/class";
	
	unless ($config->elementExists($classPath)) {
	    $self->error("cannot get $classPath");
	    return;
	}
	
	my $cel = $config->getElement($classPath); #current sensor class
	
	while ($cel->hasNextElement()) {
	    my $class = $cel->getNextElement();
	    
	    # the fields of a class are stored into a list of hashes since
	    # we need various kinds of info about each field (name, type, key..)
	    my @fields = ();
	    
	    while ($class->hasNextElement()) {
		my $class_ins = $class->getNextElement();
		my $valname = $class_ins->getName();
		my $val = $class_ins->getValue();
		
		if ($valname eq 'name') {
		    $classes{$class_key}{name} = $val;
		} elsif ($valname eq 'descr') {
		    $classes{$class_key}{desc} = $val;
		} elsif ($valname eq 'field') {
		    # a hash for each field
		    my %field_vals = ();
		    #artificial key again, to maintain the order of the fields
		    my $field_key = 1; 
		    
		    while ($class_ins->hasNextElement()) {
			my $field = $class_ins->getNextElement();
			
			while ($field->hasNextElement()) {
			    my $field_el = $field->getNextElement();
			    my $field_el_name = $field_el->getName();
			    my $field_el_val = $field_el->getValue();
			    
			    if ($field_el_name eq 'name') {
				$field_vals{$field_key}{name} = CleanName($field_el_val);
				
			    } elsif ($field_el_name eq 'descr') {
				$field_vals{$field_key}{desc} = $field_el_val;
				
			    } elsif ($field_el_name eq 'unit') {
				$field_vals{$field_key}{unit} = $field_el_val;			      
				
			    } elsif ($field_el_name eq 'scale') {
				$field_vals{$field_key}{scale} = $field_el_val;				
				
			    } elsif ($field_el_name eq 'format') {
				
				if ($field_el_val =~ /^%ld/ or 
				   $field_el_val eq 'integer') { #integer
				    $field_vals{$field_key}{type} = "INTEGER";
				    
				} elsif ($field_el_val =~ /^(%)(.)+f$/ or
					$field_el_val eq 'float') { #float 
				    $field_vals{$field_key}{type} = "FLOAT";
				    
				} elsif ($field_el_val =~ /^(%)([0-9]+)s/) { #char
				    my $length = $2;
				    $length = 10 if $length < 10;
				    
				    $field_vals{$field_key}{type} = "CHAR";
				    $field_vals{$field_key}{length} = $length;
				} elsif ($field_el_val =~ /^char(\d+)/) { #char
				    my $length = $1;
				    $length = 10 if $length < 10;
				    
				    $field_vals{$field_key}{type} = "CHAR";
				    $field_vals{$field_key}{length} = $length;
				}
			    } elsif ($field_el_name eq 'primary') {
				$field_vals{$field_key}{primary} = $field_el_val;
				
				#is latestonly field actually used?
			    } elsif ($field_el_name eq 'default') {
				$field_vals{$field_key}{default} = $field_el_val;
			    }
			} #while
			$field_key++;
		    }
		    push @fields, \%field_vals;	
		} #elsif field
	    } #while
	    $classes{$class_key}{fields} = \@fields;
	    $class_key++;
	} #while 
    } #while
    
    #print the hashes to a file
    $filecontents .= "\tMetricClasses\n";
    
    for my $key (sort {$classes{$a}{name} cmp $classes{$b}{name}} keys %classes) {
	$filecontents .= "\t\t$classes{$key}{name}\n" if $classes{$key}{name};
	if ($classes{$key}{desc}) {
	    $filecontents .= "\t\t\tDescription $classes{$key}{desc}\n";
	} else {
	    $filecontents .= "\t\t\tDescription not available\n";
	}
	$filecontents .= "\t\t\tFields\n";
	
	my @tmpfields = $classes{$key}{fields}->[0];
	
	#the tmpfields is a bit silly, as it is a list containing only
	#one item. So, it seems that it has one dimension too many. 
	my $iterator = 0;
	while ($tmpfields[$iterator]) {
	    my %field = %{$tmpfields[$iterator]};
	    
	    for my $fkey (sort { $a <=> $b } keys %field) {
		$filecontents .= "\t\t\t\t$field{$fkey}{name}\n"; 
		
		if ($field{$fkey}{type}) {
		    $filecontents .= "\t\t\t\t\tType $field{$fkey}{type}\n";
		} else {
		    $self->warn("no type defined for field $field{$fkey}{name} in class $classes{$key}{name}"); 
		}
		
		$filecontents .= "\t\t\t\t\tFieldLength $field{$fkey}{length}\n"  if ($field{$fkey}{length});
		$filecontents .= "\t\t\t\t\tPrimaryKey\n" if ($field{$fkey}{primary} and $field{$fkey}{primary} eq 'true');
		$filecontents .= "\t\t\t\t\tMetricUnit $field{$fkey}{unit}\n"  if ($field{$fkey}{unit});
		if ($field{$fkey}{scale}){
		    my $scale = sprintf("%e",$field{$fkey}{scale});
		    $filecontents .= "\t\t\t\t\tMetricScale $scale\n" if ($field{$fkey}{scale});
		}
		$filecontents .= "\t\t\t\t\tDescription $field{$fkey}{desc}\n"  if ($field{$fkey}{desc});
		$filecontents .= "\t\t\t\t\tDefault $field{$fkey}{default}\n"  if (exists($field{$fkey}{default}));
	    } #for $fkey
	    $iterator++;
	}
    }
    
    #Part 2: Journey Through the Tree Of Metric Instances
    my $metricPath = $root.'metric/';
    
    unless ($config->elementExists($metricPath)) {
	$self->error("cannot get $metricPath");
	return;
    }
    
    my $metriclist = $config->getElement($metricPath);
    
    while ($metriclist->hasNextElement()) {
	my $cm = $metriclist->getNextElement(); #current metric
	my $mid = $cm->getName();
	
	$mid =~ s/_//; #strip the leading underscore from metric id
	
	# check whether this mid hasn't been alredy used
	if (exists($metrics{$mid})) {
	    $self->error("Metric ID $mid defined twice.");
	}
	
	$metrics{$mid}{table} = "_".$mid;
	
	#loop through all elements and stuff them into the hash
	while ($cm->hasNextElement()) {
	    my $el = $cm->getNextElement();
	    my $name = $el->getName(); 
	    
	    if ($name eq 'class') {
		$metrics{$mid}{class} = $el->getValue();
	    } elsif ($name eq 'descr') {
		$metrics{$mid}{desc} = $el->getValue();
	    } elsif ($name eq 'name') {
		$metrics{$mid}{name} = $el->getValue();
	    } elsif ($name eq 'latestonly') {
		$metrics{$mid}{latestonly} = $el->getValue();
	    } elsif ($name eq 'latest_clean') {
		$metrics{$mid}{latest_clean} = $el->getValue();
	    } elsif ($name eq 'latest_expires') {
		$metrics{$mid}{latest_expires} = $el->getValue();
	    } elsif ($name eq 'schema_version') {
		$metrics{$mid}{schema_version} = $el->getValue();
	    } elsif ($name eq 'priority') {
		$metrics{$mid}{priority} = $el->getValue();
            }
	}
    } #while
    
    # part 3: exceptions
    my $exceptionPath = $root.'exception/';
    if ($config->elementExists($exceptionPath)){
	my $exceptionlist = $config->getElement($exceptionPath);
	
	while ($exceptionlist->hasNextElement()) {
	    my $cm = $exceptionlist->getNextElement(); #current metric
	    my $mid = $cm->getName();
	    
	    $mid =~ s/_//; #strip the leading underscore from metric id
	    
	    # check whether this mid hasn't been alredy used
	    if (exists($metrics{$mid})) {
		$self->error("Metric ID $mid defined twice.");
	    }
	    
	    $metrics{$mid}{table} = "_".$mid;
	    $metrics{$mid}{class} = "alarm.exception";
	    
	    #loop through all elements and stuff them into the hash
	    while ($cm->hasNextElement()) {
		my $el = $cm->getNextElement();
		my $name = $el->getName(); 
		
		if ($name eq 'descr') {
		    $metrics{$mid}{desc} = $el->getValue();
		} elsif ($name eq 'name') {
		    $metrics{$mid}{name} = "exception.".$el->getValue();
		} elsif ($name eq 'latestonly') {
		    $metrics{$mid}{latestonly} = $el->getValue();
		} elsif ($name eq 'latest_clean') {
		    $metrics{$mid}{latest_clean} = $el->getValue();
        	} elsif ($name eq 'latest_expires') {
		    $metrics{$mid}{latest_expires} = $el->getValue();
	        } elsif ($name eq 'schema_version') {
		    $metrics{$mid}{schema_version} = $el->getValue();
  	        } elsif ($name eq 'priority') {
		    $metrics{$mid}{priority} = $el->getValue();
                }
	    }
	}
    }
    
    $filecontents .= "\tMetrics\n";
    
    for my $key (sort { $a <=> $b } keys %metrics) {
	$filecontents .= "\t\t$key\n";
	$filecontents .= "\t\t\tMetricClass $metrics{$key}{class}\n";
	$filecontents .= "\t\t\tMetricName $metrics{$key}{name}\n";
	
	if ($metrics{$key}{desc}) {
	    $filecontents .= "\t\t\tDescription $metrics{$key}{desc}\n" if $metrics{$key}{desc};
	} else {
	    $filecontents .= "\t\t\tDescription not available\n";
	}
	
	$filecontents .= "\t\t\tTableName $metrics{$key}{table}\n";
	$filecontents .= "\t\t\tLatestOnly\n" if ($metrics{$key}{latestonly} eq 'true');
	$filecontents .= "\t\t\tLatestExpires $metrics{$key}{latest_expires}\n" if $metrics{$key}{latest_expires};
	$filecontents .= "\t\t\tLatestClean $metrics{$key}{latest_clean}\n" if $metrics{$key}{latest_clean};
	$filecontents .= "\t\t\tSchemaVersion $metrics{$key}{schema_version}\n" if $metrics{$key}{schema_version};
	$filecontents .= "\t\t\tPriority $metrics{$key}{priority}\n" if $metrics{$key}{priority};
    }
    
    
    unless ($NoAction) {
	# backup the old config file
	if (-f "$configFile") {
	    unless (copy("$configFile",
			 "$configFile.old", preserve => 1)) {
		$self->error("error copying /etc//oramon-server.conf file");
	    }
	}
	# print $filecontents to a tmp-file
	
	unless (file_contents("$configFile.$$",("$filecontents"))) {
	    $self->error("couldn't open $configFile.$$ for ".
			 "writing");
	    return;
	}
	
	#and once everything's done move it to the right place
	unless (move("$configFile.$$",
		     "$configFile")) {
	    $self->error("couldn't move $configFile.$$ to ".
			 "$configFile");
	    return;
	}
    }    
}


sub CleanName($){
    my $name = shift;
    $name =~ s/.*:://g;
    $name =~ s/[\:\.]/_/g;
    $name = "_$name" if $name =~ /^\d/;
    $name = substr($name,0,30);
    return $name;
}


##########################################################################
sub Unconfigure {
##########################################################################
}

1; #required for Perl modules

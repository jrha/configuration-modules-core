# ${license-info}
# ${developer-info}
# ${author-info}


package NCM::Component::xen;

#
# a few standard statements, mandatory for all components
#

use strict;
use NCM::Component;
use vars qw(@ISA $EC);
use LC::Process qw (execute);

@ISA = qw(NCM::Component);
$EC=LC::Exception::Context->new->will_store_all;

use EDG::WP4::CCM::Element;
use NCM::Check;

use File::Compare;
use File::Copy;
use File::Basename;


use constant { XENBASE   => "/etc/xen",
	       XENAUTO   => "/etc/xen/auto"
	       };




sub createConfigFile {
    our ($self, $domain_params, $filename, $createfs)=@_;

    my ($bufferr, $buffout);
    my @sorted_keys = sort { 
    if($a eq 'bootargs') { return 1; }
    elsif($b eq 'bootargs') { return -1; }
    else { return $a cmp $b; } 
    } (keys %$domain_params);

    my @vbdlist=[];

    foreach my $k (@sorted_keys) {
	my $v=$domain_params->{$k};

	if ($k eq 'disk') {
            @vbdlist=@$v;
            
            my $i =0;
            my $vbdstring="[";
            my @vbdstrlist=[];
	    
            foreach my $vbd (@vbdlist) {
                my %vbdhash=%$vbd;
		
                SetupVbds($self,$createfs,%vbdhash);
                $vbdstrlist[$i]=VbdParams(%vbdhash);                               
                $i++;
            }

	    $vbdstring.=join(',',@vbdstrlist);
            
	    $vbdstring.="]";
	    $self->verbose($vbdstring);
	    PrintSimpleParams($filename, $vbdstring, 'disk');
            
	} elsif ($k eq 'vif') {
            
	    my @viflist = @$v;
	    my $vifstring="[";
	    foreach my $vif (@viflist) {
                $vif="'".$vif."'";
	    }
	    $vifstring.=join(',',@viflist);
	    $vifstring.="]";
	    
	    PrintSimpleParams($filename, $vifstring, 'vif');
	    
            

	} elsif ($k eq 'download') {

	    my @downloadlist = @$v;
	    foreach my $d (@downloadlist){
		my $dfile=$d;
		$self->verbose($dfile);
		execute(["$dfile"], "stderr" => \$bufferr, "stdout"=>\$buffout);
	    }
	} else {

	    my $name=$k;
	    my $value = $v;

	    $self->verbose("\t$k=$v");
	    if (index($value,'[') == -1) {
		$value="'".$value."'";
	    }
	    PrintSimpleParams($filename, $value, $k); # if ($k ne "bootloader");
#	    $value = "'restart'" if($k =~ /on_reboot/ || $k =~ /on_crash/);
#	    PrintSimpleParams($filename_start, $value, $k);

	}

    }
    $domain_params->{'vbd'}=\@vbdlist;


}

sub PrintSimpleParams  {
    our($filename, $param_value, $param)=@_;

    my $safe_param_value=$param_value;
    
    # escape square braces in the parameter
    $safe_param_value =~ s/(\[)/\\$1/g;
    $safe_param_value =~ s/(\])/\\$1/g;
    
    if ( ! -e $filename ) {
        open ( CONF,">$filename" );
        print CONF "#  -*- mode: python; -*-\n".
"#============================================================================\n".
"# Python configuration setup for 'xm create'.\n".
"# This script sets the parameters used when a domain is created using 'xm create'.\n".
"# You use a separate script for each domain you want to create, or\n".
"# you can set the parameters for the domain on the xm command line.\n".
"#\n".
"# Generated by ncm-xen at ".scalar(localtime)."\n".
"#============================================================================"
;
        close (CONF);
#        $self->log("$filename created");
    }
    
    NCM::Check::lines($filename,
                      backup => ".old",
                      linere => '^#?\s*'.$param.'(\s+|=).*',
                      goodre => '^\s*'.$param.'\s*=\s*'.$safe_param_value.'\s*',
                      good   => "$param = ".$param_value,
                      add => 'last'
                      );
    
    
    
}


sub SetupVbds {
    our ($self,$createfs,%vbdhash)=@_;

    my $type=$vbdhash{'type'};

    my $bufferr="", my $buffout="";

    if (! $createfs) {
	$self->verbose("Not creating filesystems as create_filesystems is false");
    }

    if ($type eq 'lvm') {
        $self->verbose("Configuring VBD of type ".$type);
        
        # Check if hostdevice exists
        my $hostdevice=$vbdhash{'hostdevice'};

        $self->verbose("Checking if VG $hostdevice exists");        
        my $bufferr="", my $buffout="";
        execute(["vgs",$hostdevice], "stderr" => \$bufferr, "stdout"=>\$buffout);
        if ($? != 0 && $vbdhash{'create'}) {
           #$self->error("Volume group $hostdevice does not exist");
              my $path=$vbdhash{'path'};
              $self->info("Volume group $hostdevice does not exist, will try to create on $path");

                 execute(["vgcreate", "$hostdevice","$path"],"stderr" => \$bufferr, "stdout"=>\$buffout);

        }
        else {

        
            # Check if hostvol exists
            my $hostvol=$vbdhash{'hostvol'};
            my $volsize=$vbdhash{'size'};
            
            $self->verbose("Checking if LV $hostvol exists");

            execute(["lvs",$hostdevice."/".$hostvol], "stderr" => \$bufferr, "stdout"=>\$buffout);
            if ($? != 0 && $vbdhash{'create'}) {
                $self->info("Logical volume $hostvol does not exist, will try to create");
                
                execute(["lvcreate", "-L", "${volsize}M", "-n", "$hostvol",  "$hostdevice"],"stderr" => \$bufferr, "stdout"=>\$buffout);
                
            }
        }
        
    }
    elsif ($type eq 'file') {
        $self->verbose( "Configuring VBD of type file");

        my $imagefilename=$vbdhash{'path'};
        # does the file exist?
        if (-e $imagefilename ) {

            $self->verbose("File $imagefilename exists");
            
            # check the size?
        }
        else {             # if not, create it using dd (very carefully)

            my $filesize=$vbdhash{'size'};
            $self->verbose("File $imagefilename of size $filesize");
            # make the directory if it doesn't exist
            my($filename, $directories, $suffix) = fileparse($imagefilename);
            $self->verbose("Creating directory $directories");
            execute(["mkdir","-p",$directories],"stderr" => \$bufferr, "stdout"=>\$buffout);

            $self->verbose("Creating new file $imagefilename of size $filesize");
            execute(["dd","if=/dev/zero","of=$imagefilename","bs=1M","count=$filesize"],"stderr" => \$bufferr, "stdout"=>\$buffout);
    
        }
    }

}

# return a string with the vbd params formatted for Xen 
# config file
sub VbdParams {
    our (%vbdhash)=@_;
    my $vbdstr="";


    my $type=$vbdhash{'type'};

    if ($type eq 'lvm') {
        my $path=$vbdhash{'path'};
        my $rw=$vbdhash{'rw'};
        my $guestdev=$vbdhash{'guestdevice'};
        my $hostdevice=$vbdhash{'hostdevice'};
        my $hostvol=$vbdhash{'hostvol'};
        my $access_method="phy";

        # use special access method if defined in the profile
        if ($vbdhash{'access_method'}) {
            $access_method=$vbdhash{'access_method'}
        }

        $vbdstr.="'$access_method:/dev/$hostdevice/$hostvol,$guestdev,$rw'";

    }
    elsif ($type eq 'file') {
        my $path=$vbdhash{'path'};
        my $rw=$vbdhash{'rw'};
        my $guestdev=$vbdhash{'guestdevice'};
        $vbdstr.="'file:$path,$guestdev,$rw'";
    }
    elsif ($type eq 'phy') {
        my $guestdev=$vbdhash{'guestdevice'};
        my $hostdevice=$vbdhash{'hostdevice'};
	my $rw=$vbdhash{'rw'};
	$vbdstr="'phy:/dev/$hostdevice,$guestdev,$rw'";
	
    }

    $vbdstr;
}

##########################################################################
sub Configure {
##########################################################################

    our ($self,$config)=@_;
    my $xen_state = IsXenHere($self);
    
    my $base_path = '/software/components/xen/';

    my $path=$base_path.'domains';

    my $bufferr="", my $buffout="";

    my $configroot=$config->getElement($base_path);
    my $configtree=$configroot->getTree;
    my $createdoms=0;
    my $createfs=0;

    if (exists $configtree->{'create_domains'}) {
        $createdoms=$configtree->{'create_domains'};
    }

    if (exists $configtree->{'create_filesystems'}) {
        $createfs=$configtree->{'create_filesystems'};
    }

    if ($config->elementExists($path)) {
        $configroot = $config->getElement($path);
        my $domains=$configroot->getTree;
	

        # iterate over domains
        foreach my $domain_name (keys (%$domains)) {
            my $domain = $domains->{$domain_name};
            # process hash of domain parameters   
            my $domain_params_ref = $domain->{'options'};
            my %domain_params=%$domain_params_ref;
#            my $domain_name=$domain_params{'name'};
	    
	    
            my $filename="/etc/xen/".$domain_name;
            my $filename_start="/etc/xen/".$domain_name.".start";
            #	    next if (! SanityCheck($self,$config,$domain_name));
            
	       
            # set up standard config file
            $self->verbose("Configuring file $filename");
            createConfigFile($self, $domain_params_ref, $filename, $createfs);
            
            # set up install-specific config file
            if (exists $domain->{'install_options'}) {
                $domain_params_ref = $domain->{'install_options'};
                $self->verbose("Configuring file $filename_start");
                createConfigFile($self, $domain_params_ref, $filename_start);
            }

            # configure auto-start
            if (exists $domain->{'auto'} ) {

                my $auto=XENAUTO.'/'.$domain_name;
		
                if ($domain->{'auto'}) {
                    $self->verbose("Setting domain $domain_name to auto-start");
                    if (! -l $auto) {
                        symlink($filename,$auto);
                    }
                } 
                else {
                    if (-l $auto) {
                        unlink($auto);
                    }
                }
            }

            # check if domain is running and if not, create it
            if ($createdoms) {
                if ( $xen_state == 0 ) {
                    execute(["xm","list"],"stderr" => \$bufferr, "stdout"=>\$buffout);
                    if ($? != 0) {
                        $self->verbose("Problem running Xen commands, can't create domains. xm output:\n".$buffout.$bufferr);
                    } 
                    else {
                        execute(["xm","list",$domain_name],"stderr" => \$bufferr, "stdout"=>\$buffout);
                        if ($? != 0) {
                            $self->verbose("Domain ".$domain_name." not running, will try to create it.");
                            execute(["xm","create",$domain_name],"stderr" => \$bufferr, "stdout"=>\$buffout);
                            if ($? != 0) {
                                $self->verbose("Problem creating ".$domain_name.": xm output:\n".$buffout.$bufferr);
                            }
                        }
                        else {
                            $self->verbose("Domain $domain_name already running: xm output".$buffout);
                        }
                    }
                }
                else {
                    $self->info("Skipping start of domain $domain_name because Xen did not appear to be running");
                }
            }
        }
    }

    ##
    ## network setup
    ##
    $path=$base_path.'network';
    if ($config->elementExists($path)) {
        $configroot = $config->getElement($path);
        my $network=$configroot->getTree;
        if (exists($network->{'removeqemunetworklibvirtautostart'}) && $network->{'removeqemunetworklibvirtautostart'}) {
            RemoveQemuNetworkLibvirtAutostart($self);
        }
        ## no else (yet)
        ## - maybe revert the renaming ?
        my $actions = '';
        if (exists($network->{'bridges'})) {
          $actions.=GetBridges($self,$network->{'bridges'});
        }
        if (exists($network->{'vlans'})) {
          $actions.=GetVlans($self,$network->{'vlans'});
        }
        if ($actions ne '') {
            MakeMultiBridge($self,$actions);
        }
    }

#### real end of configure
}
##########################################################################
sub SanityCheck {
##########################################################################
#
# Here is a sanity check to make sure that the Virtual Machine that we want to start on this host
# is not already maybe running on a different host.
# This checks also make sure that the map is kept up to date in CDB, for management of Virtual Machines.
#
# A template should contain the following information:
#"/software/components/xen/guest_map/<virtual_machine_name>/guest_mac" = "00:16:3E:11:22:33";
#"/software/components/xen/guest_map/<virtual_machine_name>/hypervisor_name" = "<hypervisor_name>";
#
# The ckec is simply, for VM <virtual_machine_name> that has to start here,
# is "<hypervisor_name>" equal to 'hostname' ?
#

    use Sys::Hostname;

    our ($self,$config,$domain_name)=@_;
    my $base_path = '/software/components/xen/guest_map';

    my $path=$base_path;
    my %guests;
    my $checkOK = 0;
    my $host = hostname();
    $host =~ s/\..*//;

    if (! $config->elementExists($path)) {
        $self->warn("Path $path is not defined in CDB. Skipping Sanity Check !!!");
        $checkOK = 1;
    }
    if ($config->elementExists($path)) {
        my $configroot = $config->getElement($path);

        # iterate over guests
        while ($configroot->hasNextElement()) {
            my $el = $configroot->getNextElement();
            my $eln = $el->getName();
            if($eln eq $domain_name){
		$self->verbose("Found Xen Guest \"$eln\" in CDB map");
		my %guest_params = $el->getHash();
                $guests{$eln}=\%guest_params;
                foreach my $k (keys %guest_params) {
                    my $v=$guest_params{$k};
                    if ( $v->isProperty() ) {
                        my $name=$v->getName();
                        my $value = $v->getValue();
                        $guest_params{$k}=$value;
                        $self->verbose("\tparameter name: $k\tvalue: $value");
                        if($k eq "hypervisor_name"){
			    if ($value ne $host){
				$self->error("$domain_name does not have the correct hypervisor name in CDB: $value iso $host");
			    }
			    else{
				$checkOK = 1;
				$self->verbose("SanityCheck OK for hypervisor name \"$value\" for \"$domain_name\" ");
			    }
			} elsif($k eq "guest_mac"){
			    # not check yet
			}
                    }
                }
            }
        }
        if(! $checkOK){
               $self->error("No Guest $domain_name was found under $base_path. Cannot execute Sanity check.");
        }
    }
    $self->verbose("SanityCheck returns $checkOK");
    return $checkOK;

}



##########################################################################
sub RemoveQemuNetworkLibvirtAutostart {
##########################################################################
#
# Remove the libvirt qemud network autostart files
#
    my $self = shift;
    my $func = "RemoveQemuNetworkLibvirtAutostart";
    
    my $libvirt_basedir = "/etc/libvirt/qemu/networks";
    my $libvirt_autodir = "$libvirt_basedir/autostart";
    
    ##
    ## Rename all files to something not .xml
    ##
    
    if ( ! -d $libvirt_autodir ){
        $self->info("$func: no directory $libvirt_autodir.");
        ## this is a good thing (nothing will autostart)        
        return 1;
    }
    
    opendir(DH, $libvirt_autodir) || $self->error("$func: can't list directory $libvirt_autodir.");
    my @fs=readdir(DH);
    closedir(DH);

    foreach my $f (@fs) {
        my $ff = "$libvirt_autodir/$f";
        next unless (-f $ff || -l $ff);
        if ($f =~ /xml$/) {
            my $new="$ff.ncm-xen.dont_start";
            rename($ff, $new) unless (-e $new);
        }
    }   
    
    ##
    ## restart libvirt service
    ## - no need to remove it with chkconfig
    ## - who knows it's useful for somthing else
    ##  
    my $bufferr="", my $buffout="";
    my $serv="/etc/init.d/libvirtd";
    my $cmd="$serv restart";
    if (-f $serv) {
        execute([$serv,"restart"],"stderr" => \$bufferr, "stdout"=>\$buffout);
        if ($? != 0) {
            $self->warn("$func: Problem restarting $serv: output:\n".$buffout.$bufferr);
        }
    }
    
    return 1;
}


##########################################################################
sub GetBridges{
##########################################################################
#
# Get information for defined bridges
#
  my $self = shift;
  my $func = "GetBridges";

  my $brs = shift;
  my $action='';
  my %bridges = %$brs;      
  
  ## action
  ## looks like
  ## $action_prefix vifnum=0 bridge=xenbr0 netdev=eth0
  my $action_prefix='                $script "$OP"';
  foreach my $br (sort(keys(%bridges))) {
      my $num="0";
      $num = $1 if ($br =~ m/xenbr(\d+)/);

      my $netdev="eth$num";
      my $vifnum=$num;

      if (exists($bridges{$br}{netdev})) {
          $netdev = $bridges{$br}{netdev};  
      }
      if (exists($bridges{$br}{vifnum})) {
          $vifnum = $bridges{$br}{vifnum};  
      }
      $action.="$action_prefix vifnum=$vifnum bridge=$br netdev=$netdev\n";
  }
  return $action;
}

##########################################################################
sub GetVlans{
##########################################################################
#
# Get information for defined bridges
#
  my $self = shift;
  my $func = "GetBridges";

  my $vls = shift;
  my $action='';
  my %vlans = %$vls;      
  
  ## action
  ## looks like
  ## $action_prefix vlan=2 bridge=vlanbr2 netdev=eth0
  my $action_prefix='                $vlan_script "$OP"';
  foreach my $vl (sort(keys(%vlans))) {
      my $num="2";
      $num = $1 if ($vl =~ m/vlanbr(\d+)/);

      my $netdev="eth0";
      my $vlan=$num;

      if (exists($vlans{$vl}{netdev})) {
          $netdev = $vlans{$vl}{netdev};  
      }
      if (exists($vlans{$vl}{vlan})) {
          $vlan = $vlans{$vl}{vlan};  
      }
      $action.="$action_prefix vlan=$vlan bridge=$vl netdev=$netdev\n";
  }
  return $action;
}

##########################################################################
sub MakeMultiBridge {
##########################################################################
#
# Create the multibridge script
#
    my $self = shift;
    
    my $func = "MakeMultiBridge";
    my $xen_scripts_base = XENBASE."/scripts";
    my $bs_name = "network-bridge";
    my $bs = "$xen_scripts_base/$bs_name";
    my $bs_copy="$bs.ncm-xen";
    my $vlan_copy="$bs-vlan.ncm-xen";
    my $mbs_name = "$bs_name.multi-bridge.ncm-xen";
    my $mbs = "$xen_scripts_base/$mbs_name";
    my $xen_config = XENBASE."/xend-config.sxp";
    
    my $actions=shift;
    
    if ( ! -f $bs) {
        ## ?
        $self->error("$func: can't find network-bridge-script $bs.");
        return 0;
    }

    if ( ! -f $bs_copy) {
        #make a copy
        if (! copy($bs,$bs_copy)) {
            $self->error("$func: can't create copy of $bs to $bs_copy");
            return 0;
        }
    }
    chmod 0755, $bs_copy;
    
    if ( ! -f $vlan_copy) {
      my $txt = '#!/bin/sh
#============================================================================
# Xen vlan bridge start/stop script.
# Xend calls a network script when it starts.
# The script name to use is defined in /etc/xen/xend-config.sxp
# in the network-script field.
#
# This script creates a bridge (default vlanbr${vlan}), creates a device
# (default eth0.${vlan}), and adds it to the bridge. This scrip assumes
# the Dom0 does not have an active interface on the selected vlan; if
# it does the network-bridge script should be used instead.
#
# To use this script, vconfig must be installed.
#
# Usage:
#
# network-bridge-vlan (start|stop|status) {VAR=VAL}*
#
# Vars:
#
# vlan       The vlan to bridge (default 2)
# bridge     The bridge to use (default vlanbr${vlan}).
# netdev     The interface to add to the bridge (default eth0}).
#
# Internal Vars:
# vlandev="${netdev}.${vlan}"
#
# start:
# Creates the bridge
# Adds vlandev to netdev
# Enslaves vlandev to bridge
#
# stop:
# Removes vlandev from the bridge
# Removes vlandev from netdev 
# Deletes bridge
#
# status:
# Print vlan, bridge
#
#============================================================================


dir=$(dirname "$0")
. "$dir/xen-script-common.sh"

findCommand "$@"
evalVariables "$@"

vlan=${vlan:-2}
bridge=${bridge:-vlanbr${vlan}}
netdev=${netdev:-eth0}

vlandev="${netdev}.${vlan}"

##
# link_exists interface
#
# Returns 0 if the interface named exists (whether up or down), 1 otherwise.
#
link_exists()
{
    if ip link show "$1" >/dev/null 2>/dev/null
    then
        return 0
    else
        return 1
    fi
}


# Usage: create_bridge bridge
create_bridge () {
    local bridge=$1

    # Don\'t create the bridge if it already exists.
    if ! brctl show | grep -q ${bridge} ; then
	brctl addbr ${bridge}
	brctl stp ${bridge} off
	brctl setfd ${bridge} 0
    fi
    ip link set ${bridge} up
}

# Usage: add_to_bridge bridge dev
add_to_bridge () {
    local bridge=$1
    local dev=$2
    # Don\'t add $dev to $bridge if it\'s already on a bridge.
    if ! brctl show | grep -q ${dev} ; then
	brctl addif ${bridge} ${dev}
    fi
}

# Usage: show_status vlandev bridge
# Print vlan and bridge
show_status () {
    local vlandev=$1
    local bridge=$2

    echo "============================================================"
    cat /proc/net/vlan/${vlandev}
    echo " "
    brctl show ${bridge}
    echo "============================================================"
}

op_start () {
    if [ "${bridge}" = "null" ] ; then
	return
    fi

    if ! link_exists "$netdev"; then
        return
    fi

    if link_exists "$vlandev"; then
        # The device is already up.
        return
    fi

    create_bridge ${bridge}

    ip link set ${netdev} up

    vconfig set_name_type DEV_PLUS_VID_NO_PAD
    vconfig add ${netdev} ${vlan}
    ip link set ${vlandev} address fe:ff:ff:ff:ff:ff
    ip link set ${vlandev} up
    ip link set ${bridge} up

    add_to_bridge2 ${bridge} ${vlandev}
}

op_stop () {
    if [ "${bridge}" = "null" ]; then
	return
    fi
    if ! link_exists "$bridge"; then
	return
    fi

    if link_exists "$vlandev"; then
	ip link set ${vlandev} down

	brctl delif ${bridge} ${vlandev}
	ip link set ${bridge} down

        vconfig rem ${vlandev}
    fi
    brctl delbr ${bridge}
}

# adds $dev to $bridge but waits for $dev to be in running state first
add_to_bridge2() {
    local bridge=$1
    local dev=$2
    local maxtries=10

    echo -n "Waiting for ${dev} to negotiate link."
    for i in `seq ${maxtries}` ; do
	if ifconfig ${dev} | grep -q RUNNING ; then
	    break
	else
	    echo -n '.'
	    sleep 1
	fi
    done

    if [ ${i} -eq ${maxtries} ] ; then echo "(link isnt in running state)" ; fi

    add_to_bridge ${bridge} ${dev}
}

case "$command" in
    start)
	op_start
	;;

    stop)
	op_stop
	;;

    status)
	show_status ${vlandev} ${bridge}
	;;

    *)
	echo "Unknown command: $command" >&2
	echo "Valid commands are: start, stop, status" >&2
	exit 1
esac';

      ## filecopy style
      my $changes = LC::Check::file(
                                  $vlan_copy,
                                  backup   => ".old",
                                  contents => $txt,
                                  mode => "0755",
      );
      $changes += LC::Check::status(
                                  $vlan_copy,
                                  mode => "0755",
      );
    }
    chmod 0755, $vlan_copy;
 
    my $txt = <<EOF;
#!/bin/sh
##
## Generated by ncm-xen
##
## Classical multi-bridge-script
##

# Exit if anything goes wrong
set -e
# First arg is operation.
OP=\$1
shift
script=$bs_copy
vlan_script=$vlan_copy
case "\${OP}" in
        start|stop|status)
$actions
                ;;

        *)
                echo 'Unknown command: ' \${OP}
                echo 'Valid commands are: start, stop, status'
                exit 1
esac


EOF
    
    ## filecopy style
    my $changes = LC::Check::file(
                                $mbs,
                                backup   => ".old",
                                contents => $txt,
                                mode => "0755",
    );
    $changes += LC::Check::status(
                                $mbs,
                                mode => "0755",
    );
    
    ## change xen config
    $changes += NCM::Check::lines( $xen_config,
                       linere => '^\s*\(\s*network-script\s+.*',
                       goodre => '^\s*\(\s*network-script\s+'.$mbs_name.'.*',
                       good   => "(network-script $mbs_name)",
                       keep   => 'first',
                       add    => 'last',
                       backup => '.old'
    );
    ##
    ## do something if changed? like restart the xen network?
    ##
    if ($changes) {
        $self->info("$func: something changed to either $mbs or $xen_config. Attempting a restart.");
        my $bufferr="", my $buffout="";
        execute([$mbs,"stop"],"stderr" => \$bufferr, "stdout"=>\$buffout);
        if ($? != 0) {
            $self->warn("$func: Problem stopping $mbs: output:\n".$buffout.$bufferr);
        }
        ## start it anyway?
        execute([$mbs,"start"],"stderr" => \$bufferr, "stdout"=>\$buffout);
        if ($? != 0) {
            $self->warn("$func: Problem starting $mbs: output:\n".$buffout.$bufferr);
        }
    }
     
    return 1;
}

##########################################################################
sub IsXenHere {
##########################################################################
#
# Test if Xen is avaible 
# - imagine debugging problems while you are working with non-xen kernel
#   (not that this ever happened in real life)
# - only print warnings
# - return value:
#     0:    xen appears to be present and running
#     1:    xen is present but not (yet) running
#     2:    xen is not found
#
    my $func = "IsXenHere";
    my $self = shift;
    my $bufferr="", my $buffout="";
    my $retval = 0;    

    my $exe='/usr/sbin/xm';
    if (-f $exe) {
        execute([$exe,"list"],"stderr" => \$bufferr, "stdout"=>\$buffout);
        if ($? != 0) {
            $self->info("$func: Problem with \"$exe list\": output:\n".$buffout.$bufferr);
            $retval = 1;
        }
    } else {
        $self->warn("$func: $exe not found.");
        $retval = 2;
    }
    return $retval;
}



1;

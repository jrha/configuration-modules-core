# ${license-info}
# ${developer-info}
# ${author-info}

################################################################################
#######################################################################
# NCM component for drbd daemon
#
#
# ** Generated file : do not edit **
#
#######################################################################

package NCM::Component::drbd;

#
# a few standard statements, mandatory for all components
#

use strict;
use NCM::Component;
use vars qw(@ISA $EC);
@ISA = qw(NCM::Component);
$EC=LC::Exception::Context->new->will_store_all;

use NCM::Check;
use LC::Process;
use LC::File;
use Sys::Hostname;

#
# Initialize exception handler
#
$EC->error_handler(\&my_handler);

sub my_handler {
    my($ec, $e) = @_;
    $e->has_been_reported(1);
}

##########################################################################
sub Configure {
##########################################################################
    my ($self,$config)=@_;

    my $base = '/software/components/drbd';

    my $drbd_cfg_file = '/etc/drbd.conf';
    
    my $reconfigure = 0;       # default: do NOT run drbdadm
    my $force_primary = 0;     # default: do NOT for primary host
    my %primary_host;          # primary host for each resource
    my %unmount_fs_host;       # filesystems to unmount by host

    my $drbd_cfg = "#\n# Generated by ncm-drbd at " . localtime() . "\n"
                 . "# Do not edit manually!\n"
                 . "#\n";

    # read old config file               
    my $old_drbd_cfg = LC::File::file_contents($drbd_cfg_file) || " ";
    
    # search contents for at least one resource
    my $is_new = 1;
    foreach my $line (split "\n", $old_drbd_cfg) {
        if ($line =~ /^\s*resource/) {
            $is_new = 0;
            last;
        }
    }
    
    $self->info("Configuration file $drbd_cfg_file " .
                ($is_new ? "does not exist" : "already exists"));

    # Do we need to configure automatically?
    # This is a risk if the partitions already contain data
    # and the primary and secondary are out of sync
    if ($config->elementExists("$base/reconfigure")) {
        $reconfigure = $config->getValue("$base/reconfigure");
        $self->info("Option reconfigure is: " .
                    ($reconfigure ? "enabled" : "disabled") );
    }
    
    # Should we force the primary host on a new install
    if ($config->elementExists("$base/force_primary")) {
        $force_primary = $config->getValue("$base/force_primary");
        $self->info("Option force_primary is: " .
                    ($force_primary ? "enabled" : "disabled") ); 
    }
    
    # Prepare the configuration file
    if ($config->elementExists("$base/global")) {
        $drbd_cfg .= "global {\n";
         # optional incon_degr_cmd
        if ($config->elementExists($base."/global/minor_count")) {
            $drbd_cfg .= "  minor-count "
                      .  $config->getValue($base."/global/minor_count")
                      .  ";\n";
        }
        # optional incon_degr_cmd
        if ($config->elementExists($base."/global/dialog_refresh")) {
            $drbd_cfg .= "  dialog-refresh "
                      .  $config->getValue($base."/global/dialog_refresh")
                      .  ";\n";
        }               
        # optional incon_degr_cmd
        if ($config->elementExists($base."/global/disable_io_hints")) {
            $drbd_cfg .= "  disable-io-hints "
                      .  $config->getValue($base."/global/disable_io_hints")
                      .  ";\n";
        }
        $drbd_cfg .= "}\n\n";
    }

    unless ($config->elementExists("$base/resource")) {
        $self->error("Mandatory element $base/resource missing");
        return;
    }
    
    #
    # iterate over all resources in nlist
    #
    my $res = $config->getElement("$base/resource");
    while ($res->hasNextElement()) {
        my $res_elt = $res->getNextElement();
        my $res_name = $res_elt->getName();
        $drbd_cfg .= "resource $res_name {\n";       
        
        # mandatory protocol
        my $path = "$base/resource/$res_name";
        unless ($config->elementExists($path."/protocol")) {
            $self->error("Mandatory $path/protocol does not exist");
            return;
        }
        $drbd_cfg .= "  protocol "
                  .  $config->getValue($path.'/protocol')
                  .  ";\n";     
        
        # optional incon_degr_cmd
        if ($config->elementExists($path."/incon_degr_cmd")) {
            $drbd_cfg .= "  incon-degr-cmd "
                      .  $config->getValue($path."/incon_degr_cmd")
                      .  ";\n";
        }
        $drbd_cfg .= "\n";
        
        # optional nested startup 
        if ($config->elementExists($path."/startup")) {
            $drbd_cfg .= "  startup {\n";
            
            # optional sub-element wfc_timeout
            if ($config->elementExists($path."/startup/wfc_timeout")) {
                $drbd_cfg .= "    wfc-timeout " . $config->getValue($path."/startup/wfc_timeout") . ";\n";
            }
            
            # optional sub-element degr_wfc_timeout
            if ($config->elementExists($path."/startup/degr_wfc_timeout")) {
                $drbd_cfg .= "    degr-wfc-timeout " . $config->getValue($path."/startup/degr_wfc_timeout") . ";\n";            
            }
            $drbd_cfg .= "  }\n\n";
        }

        # optional nested syncer
        if ($config->elementExists($path."/syncer")) {
            $drbd_cfg .= "  syncer {\n";

            # optional sub-element rate
            if ($config->elementExists($path."/syncer/rate")) {
                $drbd_cfg .= "    rate " . $config->getValue($path."/syncer/rate") . ";\n";
            }
            # optional sub-element group
            if ($config->elementExists($path."/syncer/group")) {
                $drbd_cfg .= "    group " . $config->getValue($path."/syncer/group") . ";\n";
            }
            # optional sub-element al_extents
            if ($config->elementExists($path."/syncer/al_extents")) {
                $drbd_cfg .= "    al-extents " . $config->getValue($path."/syncer/al_extents") . ";\n";
            }        
            $drbd_cfg .= "  }\n\n";
        }

        # optional nested net
        if ($config->elementExists($path."/net")) {
            $drbd_cfg .= "  net {\n";

            # optional sub-element sndbuf_size
            if ($config->elementExists($path."/net/sndbuf_size")) {
                $drbd_cfg .= "    sndbuf-size " . $config->getValue($path."/net/sndbuf_size") . ";\n";
            }        
            # optional sub-element timeout
            if ($config->elementExists($path."/net/timeout")) {
                $drbd_cfg .= "    timeout " . $config->getValue($path."/net/timeout") . ";\n";
            }        
            # optional sub-element connect_int
            if ($config->elementExists($path."/net/connect_int")) {
                $drbd_cfg .= "    connect-int " . $config->getValue($path."/net/connect_int") . ";\n";
            }        
            # optional sub-element ping_int
            if ($config->elementExists($path."/net/ping_int")) {
                $drbd_cfg .= "    ping-int " . $config->getValue($path."/net/ping_int") . ";\n";
            }        
            # optional sub-element max_buffers
            if ($config->elementExists($path."/net/max_buffers")) {
                $drbd_cfg .= "    max-buffers " . $config->getValue($path."/net/max_buffers") . ";\n";
            }        
            # optional sub-element max_epoch_size
            if ($config->elementExists($path."/net/max_epoch_size")) {
                $drbd_cfg .= "    max-epoch-size " . $config->getValue($path."/net/max_epoch_size") . ";\n";
            }        
            # optional sub-element unplug_watermark
            if ($config->elementExists($path."/net/unplug_watermark")) {
                $drbd_cfg .= "    unplug-watermark " . $config->getValue($path."/net/unplug_watermark") . ";\n";
            }        
            # optional sub-element ko_count
            if ($config->elementExists($path."/net/ko_count")) {
                $drbd_cfg .= "    ko-count " . $config->getValue($path."/net/ko_count") . ";\n";
            }        
            # optional sub-element on_disconnect
            if ($config->elementExists($path."/net/on_disconnect")) {
                $drbd_cfg .= "    on-disconnect " . $config->getValue($path."/net/on_disconnect") . ";\n";
            }        
            $drbd_cfg .= "  }\n\n";
        }

        # optional nested disk
        if ($config->elementExists($path."/disk")) {
            $drbd_cfg .= "  disk {\n";

            # optional sub-element on_io_error
            if ($config->elementExists($path."/disk/on_io_error")) {
                $drbd_cfg .= "    on-io-error " . $config->getValue($path."/disk/on_io_error") . ";\n";
            }        
            $drbd_cfg .= "  }\n\n";
        }

        # if a primary host was configured , store it for later usage
        my $primary_host = undef;
        if ($config->elementExists($path."/primary_host")) {
            $primary_host = $config->getValue($path."/primary_host");
            $self->info("primary host = $primary_host");
        }
        
        # nested hosts        
        unless ($config->elementExists($path."/hosts")) {
            $self->error("Mandatory $path/hosts does not exist");
            return;
        }       
        my $hosts = $config->getElement($path."/hosts");
        my $host_index = 0;
        while ($hosts->hasNextElement()) {
            my $h_elt = $hosts->getNextElement();            
            
            # first check for mandatory hostname, device, disk
            # address and meta_disk
            my $hpath = $h_elt->getPath()->toString();
            unless ($config->elementExists($hpath."/hostname")) {
                $self->error("Mandatory $hpath/hostname does not exist");
                return;
            }
            unless ($config->elementExists($hpath."/device")) {
                $self->error("Mandatory $hpath/device does not exist");
                return;
            }
            unless ($config->elementExists($hpath."/disk")) {
                $self->error("Mandatory $hpath/disk does not exist");
                return;
            }
            unless ($config->elementExists($hpath."/address")) {
                $self->error("Mandatory $hpath/address does not exist");
                return;
            }
            unless ($config->elementExists($hpath."/meta_disk")) {
                $self->error("Mandatory $hpath/meta_disk does not exist");
                return;
            }
            $drbd_cfg .= "  on " .  $config->getValue($hpath."/hostname") .  " {\n"
                      .  "    device " . $config->getValue($hpath."/device") . ";\n"
                      .  "    disk " . $config->getValue($hpath."/disk") . ";\n"
                      .  "    address " . $config->getValue($hpath."/address") . ";\n"
                      .  "    meta-disk " . $config->getValue($hpath."/meta_disk") . ";\n"
                      .  "  }\n\n";            
                      
            # if matching, store the current hostname as primary one
            if (defined($primary_host) and $host_index == $primary_host) {          
                my $hostname = $config->getValue($hpath."/hostname");
                $primary_host{$res_name} = $hostname;
            }
            $host_index++;
            
            # the data and metadata file systems should be unmounted
            my $metadisk = $config->getValue($hpath."/meta_disk");
            $metadisk =~ s/\[\d+\]\s*$//;
            $unmount_fs_host{hostname}{$config->getValue($hpath."/disk")}++;
            $unmount_fs_host{hostname}{$metadisk}++;
        }
        
        # end of resource section
        $drbd_cfg .= "}\n";        
    }
    

    #
    # Only modify the file if the configuration actually changed
    #
    if ($old_drbd_cfg ne $drbd_cfg) {
        unless (LC::File::file_contents($drbd_cfg_file,$drbd_cfg)) {
            $self->error("Can't write $drbd_cfg_file");
            return;
        }
        $self->log("Wrote new configuration to $drbd_cfg_file");
    }
    
    #
    # If requested, let the new configuration take effect    
    #   
    if ($reconfigure) {
        # ensure that the file systems are not mounted
        my $fstab_file = "/etc/fstab";
        my $fstab = LC::File::file_contents($fstab_file);
        unless ($fstab) {
            $self->error("Failed to get contents of $fstab_file");
            return;
        }
        
        my ($err, $ret);
        my @fstab = (split "\n", $fstab);
        
        my $href = $unmount_fs_host{hostname};
        for my $fs (sort keys %$href) {
            # unmount the file system
            $self->info("Unmounting FS $fs and removing from $fstab_file");

            $ret = LC::Process::execute(["umount",$fs], 
                                           "stderr" => \$err);
            unless (defined($ret) and $ret) {
                $self->warn("umount $fs failed with code $?:\n$err");
            }
                
            for (my $i=0; $i<@fstab; $i++) {
                if ($fstab[$i] =~ /^\s+$fs\s*/) {
                    $self->info("Comment out line: $fstab[$i]");
                    $fstab[$i] = "# " . $fstab[$i];
                }
            }
        }
        
        # construct the contents of the new fstab and write it to file
        my $new_fstab = join("\n", @fstab) . "\n";
        if ($fstab ne $new_fstab) {
            unless (LC::File::file_contents($fstab_file,$new_fstab)) {
                $self->error("Can't write $fstab_file");
                return;
            }
            $self->log("Wrote new configuration to $fstab_file");
        }        

	# check metadata
	my $res = $config->getElement("$base/resource");
	while ($res->hasNextElement()) {
	    my $res_elt = $res->getNextElement();
	    my $res_name = $res_elt->getName();
	    my $out;
	    $self->debug(5, "Checking $res_name metadata");
	    $ret = LC::Process::execute(["/sbin/drbdadm","dump-md",$res_name],
                                    "stdout" => \$out, "stderr" => \$err);
#	    drbdadm  dump-md drbd-sdb1
	    unless (defined($ret) and $ret and ($?==0 or $? == 5120)) {
		$self->warn("problem with metadata code $?:\n$err");

		# try to create metadata
        $self->debug(5, "Trying to create $res_name metadata");
		$ret = LC::Process::execute(["/sbin/drbdadm","create-md",$res_name],
					    "stderr" => \$err);
		unless (defined($ret) and $ret and $?==0) {
		    $self->error("problem with creating metadata code $?:\n$err");
		    return;

		}
	    }
	};
	# start the daemon
        $self->info("Starting DRBD daemon");
        $ret = LC::Process::execute(["/sbin/service","drbd","start"],
                                    "stderr" => \$err);
	
        unless (defined($ret) and $ret) {
            $self->error("service drbd start failed with code $?:\n$err");
            return;
        }
            
        # first a dry run
        $self->info("Doing dry run of drbdadm");
        $ret = LC::Process::execute(["drbdadm","-d","adjust","all"],
                                    "stderr" => \$err);
        unless (defined($ret) and $ret) {
            $self->error("Dry run of drbdadm failed with code $?:\n$err");
            return;
        }
        
        # now the real run
        $self->info("Real run of drbdadm");
        $ret = LC::Process::execute(["drbdadm","adjust","all"], 
                                    "stderr" => \$err);
        unless (defined($ret) && $ret) {
            $self->error("Running drbdadm failed with code $?");
            return;
        }
    }
    else {
        $self->info("Option reconfigure is false; reconfigure manually");
    }
    
    #
    # !! The following is DANGEROUS !!
    #
    # If requested, configured, only when installing 
    # (i.e., there was no existing DRBD config file at component start),
    # and the other host is not the active primary,
    # make the current host the primary one.
    #
    # Forcing a host to become primary could lead to data loss
    # if the other host is the active primary and the current host
    # is not synchronized.
    #    
    if ($is_new and $force_primary) {
        # check that there is no other primary host
        my @procdrbd = grep {/st:\w+\/\w+/} `cat /proc/drbd`;
        $self->info("procdrbd: " . join("\n",@procdrbd));
        
        my ($ret, $err);
    
        # configure the primary host per resource
        for my $res (keys %primary_host) {
            my $prim = $primary_host{$res};
            
            $self->info("Comparing configured primary $prim with current host " . hostname);
            if ($prim eq hostname) {
                $self->info("Configuring $prim as primary host " .
                            "for resource $res");
                my $cmd = "drbdadm -- --do-what-I-say primary $res";
                $self->info($cmd);
                
                my @cmdargs = (split /\s+/, $cmd);
                $ret = LC::Process::execute(\@cmdargs, "stderr" => \$err);
                unless (defined($ret) && $ret) {
                    $self->error("Command $cmd failed with code $?:\n$err");
                    return;
                }
            }
        }
    }
    
    return;
}

##########################################################################
sub Unconfigure {
##########################################################################
}


        
1; #required for Perl modules
